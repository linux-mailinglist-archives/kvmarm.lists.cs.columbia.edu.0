Return-Path: <kvmarm-bounces@lists.cs.columbia.edu>
X-Original-To: lists+kvmarm@lfdr.de
Delivered-To: lists+kvmarm@lfdr.de
Received: from mm01.cs.columbia.edu (mm01.cs.columbia.edu [128.59.11.253])
	by mail.lfdr.de (Postfix) with ESMTP id 7928F45A639
	for <lists+kvmarm@lfdr.de>; Tue, 23 Nov 2021 16:06:16 +0100 (CET)
Received: from localhost (localhost [127.0.0.1])
	by mm01.cs.columbia.edu (Postfix) with ESMTP id E58464B201;
	Tue, 23 Nov 2021 10:06:15 -0500 (EST)
X-Virus-Scanned: at lists.cs.columbia.edu
X-Spam-Flag: NO
X-Spam-Score: -4.201
X-Spam-Level: 
X-Spam-Status: No, score=-4.201 required=6.1 tests=[BAYES_00=-1.9,
	DNS_FROM_AHBL_RHSBL=2.699, RCVD_IN_DNSWL_HI=-5] autolearn=unavailable
Received: from mm01.cs.columbia.edu ([127.0.0.1])
	by localhost (mm01.cs.columbia.edu [127.0.0.1]) (amavisd-new, port 10024)
	with ESMTP id W9Yw7PXk9fB5; Tue, 23 Nov 2021 10:06:15 -0500 (EST)
Received: from mm01.cs.columbia.edu (localhost [127.0.0.1])
	by mm01.cs.columbia.edu (Postfix) with ESMTP id 8AD284B1FE;
	Tue, 23 Nov 2021 10:06:14 -0500 (EST)
Received: from localhost (localhost [127.0.0.1])
 by mm01.cs.columbia.edu (Postfix) with ESMTP id 7A36F4B1C5
 for <kvmarm@lists.cs.columbia.edu>; Tue, 23 Nov 2021 10:06:13 -0500 (EST)
X-Virus-Scanned: at lists.cs.columbia.edu
Received: from mm01.cs.columbia.edu ([127.0.0.1])
 by localhost (mm01.cs.columbia.edu [127.0.0.1]) (amavisd-new, port 10024)
 with ESMTP id LOl6eWaLmK+P for <kvmarm@lists.cs.columbia.edu>;
 Tue, 23 Nov 2021 10:06:12 -0500 (EST)
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
 by mm01.cs.columbia.edu (Postfix) with ESMTPS id 3208A4B1AD
 for <kvmarm@lists.cs.columbia.edu>; Tue, 23 Nov 2021 10:06:12 -0500 (EST)
Received: from disco-boy.misterjones.org (disco-boy.misterjones.org
 [51.254.78.96])
 (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
 (No client certificate requested)
 by mail.kernel.org (Postfix) with ESMTPSA id 34BBB60C49;
 Tue, 23 Nov 2021 15:06:11 +0000 (UTC)
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
 by disco-boy.misterjones.org with esmtpsa (TLS1.3) tls
 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (Exim 4.94.2)
 (envelope-from <maz@kernel.org>)
 id 1mpXN2-007JJp-QT; Tue, 23 Nov 2021 15:06:08 +0000
Date: Tue, 23 Nov 2021 15:06:08 +0000
Message-ID: <87h7c2di8v.wl-maz@kernel.org>
From: Marc Zyngier <maz@kernel.org>
To: Ricardo Koller <ricarkol@google.com>
Subject: Re: [PATCH 02/17] KVM: selftests: aarch64: add function for accessing
 GICv3 dist and redist registers
In-Reply-To: <20211109023906.1091208-3-ricarkol@google.com>
References: <20211109023906.1091208-1-ricarkol@google.com>
 <20211109023906.1091208-3-ricarkol@google.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: ricarkol@google.com, kvm@vger.kernel.org,
 kvmarm@lists.cs.columbia.edu, drjones@redhat.com, eric.auger@redhat.com,
 alexandru.elisei@arm.com, pbonzini@redhat.com, oupton@google.com,
 james.morse@arm.com, suzuki.poulose@arm.com, shuah@kernel.org,
 jingzhangos@google.com, pshier@google.com, rananta@google.com,
 reijiw@google.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org);
 SAEximRunCond expanded to false
Cc: kvm@vger.kernel.org, shuah@kernel.org, pshier@google.com,
 Paolo Bonzini <pbonzini@redhat.com>, kvmarm@lists.cs.columbia.edu
X-BeenThere: kvmarm@lists.cs.columbia.edu
X-Mailman-Version: 2.1.14
Precedence: list
List-Id: Where KVM/ARM decisions are made <kvmarm.lists.cs.columbia.edu>
List-Unsubscribe: <https://lists.cs.columbia.edu/mailman/options/kvmarm>,
 <mailto:kvmarm-request@lists.cs.columbia.edu?subject=unsubscribe>
List-Archive: <https://lists.cs.columbia.edu/pipermail/kvmarm>
List-Post: <mailto:kvmarm@lists.cs.columbia.edu>
List-Help: <mailto:kvmarm-request@lists.cs.columbia.edu?subject=help>
List-Subscribe: <https://lists.cs.columbia.edu/mailman/listinfo/kvmarm>,
 <mailto:kvmarm-request@lists.cs.columbia.edu?subject=subscribe>
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit
Errors-To: kvmarm-bounces@lists.cs.columbia.edu
Sender: kvmarm-bounces@lists.cs.columbia.edu

On Tue, 09 Nov 2021 02:38:51 +0000,
Ricardo Koller <ricarkol@google.com> wrote:
> 
> Add a generic library function for reading and writing GICv3 distributor
> and redistributor registers. Then adapt some functions to use it; more
> will come and use it in the next commit.
> 
> Signed-off-by: Ricardo Koller <ricarkol@google.com>
> ---
>  .../selftests/kvm/lib/aarch64/gic_v3.c        | 124 ++++++++++++++----
>  1 file changed, 101 insertions(+), 23 deletions(-)
> 
> diff --git a/tools/testing/selftests/kvm/lib/aarch64/gic_v3.c b/tools/testing/selftests/kvm/lib/aarch64/gic_v3.c
> index 2dbf3339b62e..00e944fd8148 100644
> --- a/tools/testing/selftests/kvm/lib/aarch64/gic_v3.c
> +++ b/tools/testing/selftests/kvm/lib/aarch64/gic_v3.c
> @@ -19,7 +19,8 @@ struct gicv3_data {
>  	unsigned int nr_spis;
>  };
>  
> -#define sgi_base_from_redist(redist_base) (redist_base + SZ_64K)
> +#define sgi_base_from_redist(redist_base) 	(redist_base + SZ_64K)
> +#define DIST_BIT				(1U << 31)
>  
>  enum gicv3_intid_range {
>  	SGI_RANGE,
> @@ -50,6 +51,14 @@ static void gicv3_gicr_wait_for_rwp(void *redist_base)
>  	}
>  }
>  
> +static void gicv3_wait_for_rwp(uint32_t cpu_or_dist)
> +{
> +	if (cpu_or_dist & DIST_BIT)
> +		gicv3_gicd_wait_for_rwp();
> +	else
> +		gicv3_gicr_wait_for_rwp(gicv3_data.redist_base[cpu_or_dist]);
> +}
> +
>  static enum gicv3_intid_range get_intid_range(unsigned int intid)
>  {
>  	switch (intid) {
> @@ -81,39 +90,108 @@ static void gicv3_write_eoir(uint32_t irq)
>  	isb();
>  }
>  
> -static void
> -gicv3_config_irq(unsigned int intid, unsigned int offset)
> +uint32_t gicv3_reg_readl(uint32_t cpu_or_dist, uint64_t offset)
> +{
> +	void *base = cpu_or_dist & DIST_BIT ? gicv3_data.dist_base
> +		: sgi_base_from_redist(gicv3_data.redist_base[cpu_or_dist]);
> +	return readl(base + offset);
> +}
> +
> +void gicv3_reg_writel(uint32_t cpu_or_dist, uint64_t offset, uint32_t reg_val)
> +{
> +	void *base = cpu_or_dist & DIST_BIT ? gicv3_data.dist_base
> +		: sgi_base_from_redist(gicv3_data.redist_base[cpu_or_dist]);
> +	writel(reg_val, base + offset);
> +}
> +
> +uint32_t gicv3_getl_fields(uint32_t cpu_or_dist, uint64_t offset, uint32_t mask)
> +{
> +	return gicv3_reg_readl(cpu_or_dist, offset) & mask;
> +}
> +
> +void gicv3_setl_fields(uint32_t cpu_or_dist, uint64_t offset,
> +		uint32_t mask, uint32_t reg_val)
> +{
> +	uint32_t tmp = gicv3_reg_readl(cpu_or_dist, offset) & ~mask;
> +
> +	tmp |= (reg_val & mask);
> +	gicv3_reg_writel(cpu_or_dist, offset, tmp);
> +}
> +
> +/*
> + * We use a single offset for the distributor and redistributor maps as they
> + * have the same value in both. The only exceptions are registers that only
> + * exist in one and not the other, like GICR_WAKER that doesn't exist in the
> + * distributor map. Such registers are conveniently marked as reserved in the
> + * map that doesn't implement it; like GICR_WAKER's offset of 0x0014 being
> + * marked as "Reserved" in the Distributor map.
> + */
> +static void gicv3_access_reg(uint32_t intid, uint64_t offset,
> +		uint32_t reg_bits, uint32_t bits_per_field,
> +		bool write, uint32_t *val)
>  {
>  	uint32_t cpu = guest_get_vcpuid();
> -	uint32_t mask = 1 << (intid % 32);
>  	enum gicv3_intid_range intid_range = get_intid_range(intid);
> -	void *reg;
> -
> -	/* We care about 'cpu' only for SGIs or PPIs */
> -	if (intid_range == SGI_RANGE || intid_range == PPI_RANGE) {
> -		GUEST_ASSERT(cpu < gicv3_data.nr_cpus);
> -
> -		reg = sgi_base_from_redist(gicv3_data.redist_base[cpu]) +
> -			offset;
> -		writel(mask, reg);
> -		gicv3_gicr_wait_for_rwp(gicv3_data.redist_base[cpu]);
> -	} else if (intid_range == SPI_RANGE) {
> -		reg = gicv3_data.dist_base + offset + (intid / 32) * 4;
> -		writel(mask, reg);
> -		gicv3_gicd_wait_for_rwp();
> -	} else {
> -		GUEST_ASSERT(0);
> -	}
> +	uint32_t fields_per_reg, index, mask, shift;
> +	uint32_t cpu_or_dist;
> +
> +	GUEST_ASSERT(bits_per_field <= reg_bits);
> +	GUEST_ASSERT(*val < (1U << bits_per_field));
> +	/* Some registers like IROUTER are 64 bit long. Those are currently not
> +	 * supported by readl nor writel, so just asserting here until then.
> +	 */
> +	GUEST_ASSERT(reg_bits == 32);

IROUTER *does* support 32bit accesses. There are no 64bit MMIO
registers in the GIC architecture that do not support 32bit accesses,
if only because there is no guarantee about the width of the MMIO bus
itself (not to mention the existence of 32bit CPUs!).

See 12.1.3 ("GIC memory-mapped register access") in the GICv3 arch
spec.
	M.

-- 
Without deviation from the norm, progress is not possible.
_______________________________________________
kvmarm mailing list
kvmarm@lists.cs.columbia.edu
https://lists.cs.columbia.edu/mailman/listinfo/kvmarm
