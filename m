Return-Path: <kvmarm-bounces@lists.cs.columbia.edu>
X-Original-To: lists+kvmarm@lfdr.de
Delivered-To: lists+kvmarm@lfdr.de
Received: from mm01.cs.columbia.edu (mm01.cs.columbia.edu [128.59.11.253])
	by mail.lfdr.de (Postfix) with ESMTP id 05BC7585A7F
	for <lists+kvmarm@lfdr.de>; Sat, 30 Jul 2022 14:52:51 +0200 (CEST)
Received: from localhost (localhost [127.0.0.1])
	by mm01.cs.columbia.edu (Postfix) with ESMTP id 2B4334D3E7;
	Sat, 30 Jul 2022 08:52:50 -0400 (EDT)
X-Virus-Scanned: at lists.cs.columbia.edu
X-Spam-Flag: NO
X-Spam-Score: -1.789
X-Spam-Level: 
X-Spam-Status: No, score=-1.789 required=6.1 tests=[BAYES_00=-1.9,
	DKIM_SIGNED=0.1, T_DKIM_INVALID=0.01, URIBL_BLOCKED=0.001]
	autolearn=unavailable
Authentication-Results: mm01.cs.columbia.edu (amavisd-new); dkim=softfail
	(fail, message has been altered) header.i=@kernel.org
Received: from mm01.cs.columbia.edu ([127.0.0.1])
	by localhost (mm01.cs.columbia.edu [127.0.0.1]) (amavisd-new, port 10024)
	with ESMTP id BQ2sT8kVufFR; Sat, 30 Jul 2022 08:52:50 -0400 (EDT)
Received: from mm01.cs.columbia.edu (localhost [127.0.0.1])
	by mm01.cs.columbia.edu (Postfix) with ESMTP id A63244D3D9;
	Sat, 30 Jul 2022 08:52:48 -0400 (EDT)
Received: from localhost (localhost [127.0.0.1])
 by mm01.cs.columbia.edu (Postfix) with ESMTP id C4DA34D3D9
 for <kvmarm@lists.cs.columbia.edu>; Sat, 30 Jul 2022 08:52:46 -0400 (EDT)
X-Virus-Scanned: at lists.cs.columbia.edu
Received: from mm01.cs.columbia.edu ([127.0.0.1])
 by localhost (mm01.cs.columbia.edu [127.0.0.1]) (amavisd-new, port 10024)
 with ESMTP id iNw7QXyYV9qc for <kvmarm@lists.cs.columbia.edu>;
 Sat, 30 Jul 2022 08:52:45 -0400 (EDT)
Received: from ams.source.kernel.org (ams.source.kernel.org [145.40.68.75])
 by mm01.cs.columbia.edu (Postfix) with ESMTPS id 2FBBB4D3AD
 for <kvmarm@lists.cs.columbia.edu>; Sat, 30 Jul 2022 08:52:45 -0400 (EDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
 (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
 (No client certificate requested)
 by ams.source.kernel.org (Postfix) with ESMTPS id AD922B80F97;
 Sat, 30 Jul 2022 12:52:42 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 496E5C433D6;
 Sat, 30 Jul 2022 12:52:41 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
 s=k20201202; t=1659185561;
 bh=JfxghIyyY7ae2zetv+c7vg0QQtxMxJj3XBE6Wni/+EY=;
 h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
 b=bs2uxrRYzT/TXifWcPLdVXvZKZgXZvHFXHqU5COGUpNIISh8je+llMuO4gafQ3hFK
 fHoqYQrt6MJPg4e+A8x9fWkc4v97Q19gQ3i9Ag16Aj0R/P8PKNQUEAbpXiGnhFt64R
 EoeXwOx7PCg4dnT75FPKdNWv78NsA4zBB0MHIs7z7LvN2/LnhwzZcMg83/+v/BsGol
 PibjhEu0fl3zdbbged6YUNfkZGE011zp1Sn+jiHrCpXW7c/nrRqmdOo+jQVmtvaVgB
 i9WyOkrxX0wNJraapb6wBG49jEBNFaJE40J0jHKgj59o5e3O8pXPd0zG1H/3e9AOGc
 LsRadopbY1cjw==
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
 by disco-boy.misterjones.org with esmtpsa (TLS1.3) tls
 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (Exim 4.95)
 (envelope-from <maz@kernel.org>) id 1oHlxO-00B2Q7-Vr;
 Sat, 30 Jul 2022 13:52:39 +0100
Date: Sat, 30 Jul 2022 13:52:38 +0100
Message-ID: <87r122wynd.wl-maz@kernel.org>
From: Marc Zyngier <maz@kernel.org>
To: Ricardo Koller <ricarkol@google.com>
Subject: Re: [kvm-unit-tests PATCH 3/3] arm: pmu: Remove checks for !overflow
 in chained counters tests
In-Reply-To: <87sfmiwywd.wl-maz@kernel.org>
References: <20220718154910.3923412-1-ricarkol@google.com>
 <20220718154910.3923412-4-ricarkol@google.com>
 <87sfmiwywd.wl-maz@kernel.org>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: ricarkol@google.com, kvm@vger.kernel.org,
 kvmarm@lists.cs.columbia.edu, andrew.jones@linux.dev, alexandru.elisei@arm.com,
 eric.auger@redhat.com, oliver.upton@linux.dev, reijiw@google.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org);
 SAEximRunCond expanded to false
Cc: kvm@vger.kernel.org, Andrew Jones <andrew.jones@linux.dev>,
 kvmarm@lists.cs.columbia.edu
X-BeenThere: kvmarm@lists.cs.columbia.edu
X-Mailman-Version: 2.1.14
Precedence: list
List-Id: Where KVM/ARM decisions are made <kvmarm.lists.cs.columbia.edu>
List-Unsubscribe: <https://lists.cs.columbia.edu/mailman/options/kvmarm>,
 <mailto:kvmarm-request@lists.cs.columbia.edu?subject=unsubscribe>
List-Archive: <https://lists.cs.columbia.edu/pipermail/kvmarm>
List-Post: <mailto:kvmarm@lists.cs.columbia.edu>
List-Help: <mailto:kvmarm-request@lists.cs.columbia.edu?subject=help>
List-Subscribe: <https://lists.cs.columbia.edu/mailman/listinfo/kvmarm>,
 <mailto:kvmarm-request@lists.cs.columbia.edu?subject=subscribe>
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: 7bit
Errors-To: kvmarm-bounces@lists.cs.columbia.edu
Sender: kvmarm-bounces@lists.cs.columbia.edu

Crumbs... With Drew's new email this time.

On Sat, 30 Jul 2022 13:47:14 +0100,
Marc Zyngier <maz@kernel.org> wrote:
> 
> Hi Ricardo,
> 
> On Mon, 18 Jul 2022 16:49:10 +0100,
> Ricardo Koller <ricarkol@google.com> wrote:
> > 
> > A chained event overflowing on the low counter can set the overflow flag
> > in PMOVS.  KVM does not set it, but real HW and the fast-model seem to.
> > Moreover, the AArch64.IncrementEventCounter() pseudocode in the ARM ARM
> > (DDI 0487H.a, J1.1.1 "aarch64/debug") also sets the PMOVS bit on
> > overflow.
> > 
> > The pmu chain tests fail on bare metal when checking the overflow flag
> > of the low counter _not_ being set on overflow.  Fix by removing the
> > checks.
> > 
> > Signed-off-by: Ricardo Koller <ricarkol@google.com>
> > ---
> >  arm/pmu.c | 21 ++++++++++-----------
> >  1 file changed, 10 insertions(+), 11 deletions(-)
> > 
> > diff --git a/arm/pmu.c b/arm/pmu.c
> > index a7899c3c..4f2c5096 100644
> > --- a/arm/pmu.c
> > +++ b/arm/pmu.c
> > @@ -581,7 +581,6 @@ static void test_chained_counters(void)
> >  	precise_instrs_loop(22, pmu.pmcr_ro | PMU_PMCR_E);
> >  
> >  	report(read_regn_el0(pmevcntr, 1) == 1, "CHAIN counter #1 incremented");
> > -	report(!read_sysreg(pmovsclr_el0), "no overflow recorded for chained incr #1");
> >  
> >  	/* test 64b overflow */
> >  
> > @@ -593,7 +592,7 @@ static void test_chained_counters(void)
> >  	precise_instrs_loop(22, pmu.pmcr_ro | PMU_PMCR_E);
> >  	report_info("overflow reg = 0x%lx", read_sysreg(pmovsclr_el0));
> >  	report(read_regn_el0(pmevcntr, 1) == 2, "CHAIN counter #1 set to 2");
> > -	report(!read_sysreg(pmovsclr_el0), "no overflow recorded for chained incr #2");
> > +	report((read_sysreg(pmovsclr_el0) & 0x2) == 0, "no overflow recorded for chained incr #2");
> >  
> >  	write_regn_el0(pmevcntr, 0, PRE_OVERFLOW);
> >  	write_regn_el0(pmevcntr, 1, ALL_SET);
> > @@ -601,7 +600,7 @@ static void test_chained_counters(void)
> >  	precise_instrs_loop(22, pmu.pmcr_ro | PMU_PMCR_E);
> >  	report_info("overflow reg = 0x%lx", read_sysreg(pmovsclr_el0));
> >  	report(!read_regn_el0(pmevcntr, 1), "CHAIN counter #1 wrapped");
> > -	report(read_sysreg(pmovsclr_el0) == 0x2, "overflow on chain counter");
> > +	report(read_sysreg(pmovsclr_el0) & 0x2, "overflow on chain counter");
> >  }
> >  
> >  static void test_chained_sw_incr(void)
> > @@ -626,10 +625,10 @@ static void test_chained_sw_incr(void)
> >  	for (i = 0; i < 100; i++)
> >  		write_sysreg(0x1, pmswinc_el0);
> >  
> > -	report(!read_sysreg(pmovsclr_el0) && (read_regn_el0(pmevcntr, 1) == 1),
> > -		"no overflow and chain counter incremented after 100 SW_INCR/CHAIN");
> > +	report(read_regn_el0(pmevcntr, 1) == 1,
> > +			"no chain counter incremented after 100 SW_INCR/CHAIN");
> >  	report_info("overflow=0x%lx, #0=%ld #1=%ld", read_sysreg(pmovsclr_el0),
> > -		    read_regn_el0(pmevcntr, 0), read_regn_el0(pmevcntr, 1));
> > +			read_regn_el0(pmevcntr, 0), read_regn_el0(pmevcntr, 1));
> >  
> >  	/* 64b SW_INCR and overflow on CHAIN counter*/
> >  	pmu_reset();
> > @@ -644,7 +643,7 @@ static void test_chained_sw_incr(void)
> >  	for (i = 0; i < 100; i++)
> >  		write_sysreg(0x1, pmswinc_el0);
> >  
> > -	report((read_sysreg(pmovsclr_el0) == 0x2) &&
> > +	report((read_sysreg(pmovsclr_el0) & 0x2) &&
> >  		(read_regn_el0(pmevcntr, 1) == 0) &&
> >  		(read_regn_el0(pmevcntr, 0) == 84),
> >  		"overflow on chain counter and expected values after 100 SW_INCR/CHAIN");
> > @@ -727,8 +726,8 @@ static void test_chain_promotion(void)
> >  	report_info("MEM_ACCESS counter #0 has value 0x%lx",
> >  		    read_regn_el0(pmevcntr, 0));
> >  
> > -	report((read_regn_el0(pmevcntr, 1) == 1) && !read_sysreg(pmovsclr_el0),
> > -		"CHAIN counter enabled: CHAIN counter was incremented and no overflow");
> > +	report((read_regn_el0(pmevcntr, 1) == 1),
> > +		"CHAIN counter enabled: CHAIN counter was incremented");
> >  
> >  	report_info("CHAIN counter #1 = 0x%lx, overflow=0x%lx",
> >  		read_regn_el0(pmevcntr, 1), read_sysreg(pmovsclr_el0));
> > @@ -755,8 +754,8 @@ static void test_chain_promotion(void)
> >  	report_info("MEM_ACCESS counter #0 has value 0x%lx",
> >  		    read_regn_el0(pmevcntr, 0));
> >  
> > -	report((read_regn_el0(pmevcntr, 1) == 1) && !read_sysreg(pmovsclr_el0),
> > -		"32b->64b: CHAIN counter incremented and no overflow");
> > +	report((read_regn_el0(pmevcntr, 1) == 1),
> > +		"32b->64b: CHAIN counter incremented");
> >  
> >  	report_info("CHAIN counter #1 = 0x%lx, overflow=0x%lx",
> >  		read_regn_el0(pmevcntr, 1), read_sysreg(pmovsclr_el0));
> 
> I'm looking at fixing KVM to match this (see the binch of hacks at
> [1]), and still getting a couple of failures in the PMU overflow tests
> despite my best effort to fix the code:
> 
> $ ./arm-run  arm/pmu.flat --append pmu-overflow-interrupt
> /usr/bin/qemu-system-aarch64 -nodefaults -machine virt,gic-version=host -accel kvm -cpu host -device virtio-serial-device -device virtconsole,chardev=ctd -chardev testdev,id=ctd -device pci-testdev -display none -serial stdio -kernel arm/pmu.flat --append pmu-overflow-interrupt # -initrd /tmp/tmp.RQ6FmkvXay
> INFO: PMU version: 0x1
> INFO: PMU implementer/ID code: 0x41("A")/0x3
> INFO: Implements 6 event counters
> PASS: pmu: pmu-overflow-interrupt: no overflow interrupt after preset
> PASS: pmu: pmu-overflow-interrupt: no overflow interrupt after counting
> INFO: pmu: pmu-overflow-interrupt: overflow=0x0
> PASS: pmu: pmu-overflow-interrupt: overflow interrupts expected on #0 and #1
> FAIL: pmu: pmu-overflow-interrupt: no overflow interrupt expected on 32b boundary
> FAIL: pmu: pmu-overflow-interrupt: expect overflow interrupt on odd counter
> SUMMARY: 5 tests, 2 unexpected failures
> 
> Looking at the kut code, I'm wondering whether you're still missing a
> couple of extra fixes such as:
> 
> diff --git a/arm/pmu.c b/arm/pmu.c
> index 4f2c5096..e0b9f71a 100644
> --- a/arm/pmu.c
> +++ b/arm/pmu.c
> @@ -861,8 +861,8 @@ static void test_overflow_interrupt(void)
>  	write_regn_el0(pmevcntr, 0, PRE_OVERFLOW);
>  	isb();
>  	mem_access_loop(addr, 200, pmu.pmcr_ro | PMU_PMCR_E);
> -	report(expect_interrupts(0),
> -		"no overflow interrupt expected on 32b boundary");
> +	report(expect_interrupts(1),
> +		"expect overflow interrupt on 32b counter");
>  
>  	/* overflow on odd counter */
>  	pmu_reset_stats();
> @@ -870,8 +870,8 @@ static void test_overflow_interrupt(void)
>  	write_regn_el0(pmevcntr, 1, ALL_SET);
>  	isb();
>  	mem_access_loop(addr, 400, pmu.pmcr_ro | PMU_PMCR_E);
> -	report(expect_interrupts(0x2),
> -		"expect overflow interrupt on odd counter");
> +	report(expect_interrupts(0x3),
> +		"expect overflow interrupt on even+odd counters");
>  }
>  #endif
>  
> With that, all PMU tests pass. Am I missing something? Did you notice
> these failing on HW?
> 
> Thanks,
> 
> 	M.
> 
> [1] https://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms.git/log/?h=kvm-arm64/pmu-chained
> 
> -- 
> Without deviation from the norm, progress is not possible.

-- 
Without deviation from the norm, progress is not possible.
_______________________________________________
kvmarm mailing list
kvmarm@lists.cs.columbia.edu
https://lists.cs.columbia.edu/mailman/listinfo/kvmarm
